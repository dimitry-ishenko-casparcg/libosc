////////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2020 Dimitry Ishenko
// Contact: dimitry (dot) ishenko (at) (gee) mail (dot) com
//
// Distributed under the GNU GPL license. See the LICENSE.md file for details.

////////////////////////////////////////////////////////////////////////////////
#include "bundle.hpp"
#include "element.hpp"
#include "packet.hpp"
#include "value.hpp"

#include <stdexcept>

////////////////////////////////////////////////////////////////////////////////
namespace osc
{

////////////////////////////////////////////////////////////////////////////////
inline bundle& bundle::operator<<(element e)
{
    elements_.push_back(std::move(e));
    return *this;
}

////////////////////////////////////////////////////////////////////////////////
int32 bundle::space() const
{
    int32 total = 0;
    for(auto const& e : elements()) total += e.space();
    return total;
}

////////////////////////////////////////////////////////////////////////////////
packet bundle::to_packet() const
{
    packet p;
    append_to(p);

    return p;
}

////////////////////////////////////////////////////////////////////////////////
void bundle::append_to(packet& p) const
{
    value::append_to(p, string("#bundle"));
    value::append_to(p, time());

    for(auto const& e : elements()) e.append_to(p);
}

////////////////////////////////////////////////////////////////////////////////
bool bundle::maybe(packet& p)
{
    return p.size() && p.data_[0] == '#';
}

////////////////////////////////////////////////////////////////////////////////
bundle bundle::parse(packet&)
{
    return bundle();
}

////////////////////////////////////////////////////////////////////////////////
}
